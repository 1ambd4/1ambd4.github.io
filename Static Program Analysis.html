<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Static Program Analysis | 1ambd4&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="There is nothing new under the sun.">
    
    <link rel="preload" href="/assets/css/0.styles.2e3057a1.css" as="style"><link rel="preload" href="/assets/js/app.28690c83.js" as="script"><link rel="preload" href="/assets/js/7.1117b569.js" as="script"><link rel="preload" href="/assets/js/2.2baf8a55.js" as="script"><link rel="preload" href="/assets/js/1.e277d7c2.js" as="script"><link rel="preload" href="/assets/js/14.f66e0ed2.js" as="script"><link rel="prefetch" href="/assets/js/10.f9bc6658.js"><link rel="prefetch" href="/assets/js/11.b5fc6973.js"><link rel="prefetch" href="/assets/js/15.691f4df1.js"><link rel="prefetch" href="/assets/js/16.beb8b9ab.js"><link rel="prefetch" href="/assets/js/17.a8573839.js"><link rel="prefetch" href="/assets/js/18.025b8808.js"><link rel="prefetch" href="/assets/js/19.b3f1ad65.js"><link rel="prefetch" href="/assets/js/20.ef976c17.js"><link rel="prefetch" href="/assets/js/21.a9105456.js"><link rel="prefetch" href="/assets/js/22.712410b8.js"><link rel="prefetch" href="/assets/js/23.224f5b5d.js"><link rel="prefetch" href="/assets/js/24.cd5c050e.js"><link rel="prefetch" href="/assets/js/25.40bebfc0.js"><link rel="prefetch" href="/assets/js/26.ec808e4f.js"><link rel="prefetch" href="/assets/js/27.35855ee6.js"><link rel="prefetch" href="/assets/js/28.bc30787b.js"><link rel="prefetch" href="/assets/js/29.fd5daa37.js"><link rel="prefetch" href="/assets/js/3.e5f4eeda.js"><link rel="prefetch" href="/assets/js/30.4a92f508.js"><link rel="prefetch" href="/assets/js/31.4160f1c0.js"><link rel="prefetch" href="/assets/js/32.3873b2f6.js"><link rel="prefetch" href="/assets/js/33.40f27d9a.js"><link rel="prefetch" href="/assets/js/34.1da5d8f5.js"><link rel="prefetch" href="/assets/js/35.3f4e16a9.js"><link rel="prefetch" href="/assets/js/36.c4e2cc42.js"><link rel="prefetch" href="/assets/js/37.6ad63d41.js"><link rel="prefetch" href="/assets/js/38.99f98480.js"><link rel="prefetch" href="/assets/js/39.e0f57b51.js"><link rel="prefetch" href="/assets/js/4.d64e8d60.js"><link rel="prefetch" href="/assets/js/40.0a4f7adc.js"><link rel="prefetch" href="/assets/js/5.3572f69a.js"><link rel="prefetch" href="/assets/js/6.b1eeca90.js"><link rel="prefetch" href="/assets/js/8.dd2875b9.js"><link rel="prefetch" href="/assets/js/9.190297e7.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.51cd4a88.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2e3057a1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-757b4ec5><div data-v-757b4ec5><div class="password-shadow password-wrapper-out" style="display:none;" data-v-a6c8d574 data-v-757b4ec5 data-v-757b4ec5><h3 class="title" data-v-a6c8d574>1ambd4's blog</h3> <p class="description" data-v-a6c8d574>There is nothing new under the sun.</p> <label id="box" class="inputBox" data-v-a6c8d574><input type="password" value="" data-v-a6c8d574> <span data-v-a6c8d574>Konck! Knock!</span> <button data-v-a6c8d574>OK</button></label> <div class="footer" data-v-a6c8d574><span data-v-a6c8d574><i class="iconfont reco-theme" data-v-a6c8d574></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-a6c8d574>vuePress-theme-reco</a></span> <span data-v-a6c8d574><i class="iconfont reco-copyright" data-v-a6c8d574></i> <a data-v-a6c8d574><span data-v-a6c8d574>1ambd4</span>
          
        <!---->
        2024
      </a></span></div></div> <div class="hide" data-v-757b4ec5><header class="navbar" data-v-757b4ec5><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">1ambd4's blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="undefined"></i>
  Timeline
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      1ambd4
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/1ambd4" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-757b4ec5></div> <aside class="sidebar" data-v-757b4ec5><div class="personal-info-wrapper" data-v-d1382112 data-v-757b4ec5><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-d1382112> <h3 class="name" data-v-d1382112>
    1ambd4
  </h3> <div class="num" data-v-d1382112><div data-v-d1382112><h3 data-v-d1382112>2</h3> <h6 data-v-d1382112>Articles</h6></div> <div data-v-d1382112><h3 data-v-d1382112>5</h3> <h6 data-v-d1382112>Tags</h6></div></div> <ul class="social-links" data-v-d1382112></ul> <hr data-v-d1382112></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="undefined"></i>
  Timeline
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      1ambd4
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/1ambd4" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-a6c8d574 data-v-757b4ec5><h3 class="title" data-v-a6c8d574></h3> <!----> <label id="box" class="inputBox" data-v-a6c8d574><input type="password" value="" data-v-a6c8d574> <span data-v-a6c8d574>Konck! Knock!</span> <button data-v-a6c8d574>OK</button></label> <div class="footer" data-v-a6c8d574><span data-v-a6c8d574><i class="iconfont reco-theme" data-v-a6c8d574></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-a6c8d574>vuePress-theme-reco</a></span> <span data-v-a6c8d574><i class="iconfont reco-copyright" data-v-a6c8d574></i> <a data-v-a6c8d574><span data-v-a6c8d574>1ambd4</span>
          
        <!---->
        2024
      </a></span></div></div> <div data-v-757b4ec5><div data-v-757b4ec5><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Static Program Analysis</h1> <div data-v-6008cd2c><i class="iconfont reco-account" data-v-6008cd2c><span data-v-6008cd2c>紫薯布丁</span></i> <i class="iconfont reco-date" data-v-6008cd2c><span data-v-6008cd2c>3/19/2024</span></i> <!----> <i class="tags iconfont reco-tag" data-v-6008cd2c><span class="tag-item" data-v-6008cd2c>Data Flow Analysis</span><span class="tag-item" data-v-6008cd2c>Pointer Analysis</span><span class="tag-item" data-v-6008cd2c>Lattice</span><span class="tag-item" data-v-6008cd2c>Datalog</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="static-program-analysis"><a href="#static-program-analysis" class="header-anchor">#</a> Static Program Analysis</h1> <h2 id="write-in-front"><a href="#write-in-front" class="header-anchor">#</a> Write in Front</h2> <p>HomePage: <a href="https://tai-e.pascal-lab.net/lectures.html" target="_blank" rel="noopener noreferrer">Static Program Analysis<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="lec1-introduction"><a href="#lec1-introduction" class="header-anchor">#</a> Lec1 Introduction</h2> <p>首先需要对 Static Analysis 有一个比较宏观的印象，其属于 PL 应用下的一个分发，出现的背景是虽然编程语言最核心的部分在过去的很长一段时间里，都没有发生本质的变化，但是程序的规模和复杂性却与日俱增，那么该如何确保程序的可靠性、安全性以及其他的一些保证？</p> <p>也许你会说做好 code review，确实，但将这项艰巨的任务交给人实在是不优雅，程序的事情就让程序自己来解决好了，这就是 Static Analysis 的背景（我以为的）。</p> <p>深入学习静态程序分析的附加值：</p> <ul><li>更深入的理解编程语言的语法、语义</li> <li>自然而然的写出更可靠、更安全、更高效的程序</li></ul> <p>那么，究竟什么是程序分析呢？一般认为，程序分析是在程序运行前通过分析出是否具有某些性质。比如，是否存在隐私信息泄漏，是否解引用了空指针，是否安全的进行类型转换，等等等等。</p> <p>但，有如下定理说明是不可能的。</p> <blockquote><p>Any non-trivial property of the behavior of programs in a recursively enumerable language is undecidable. - Rice's Theorem</p></blockquote> <p>莱斯定理很像香农定理之余信息论，并非在否定该方向的发展，而是给定了一个理论上界。</p> <p>一个好的静态分析，应该在保证尽量接近 soundness 的基础上，在分析精度和分析速度之间权衡。</p> <p>（算了，这部分不太想写，内容太零碎了，等等再说吧。</p> <h2 id="lec2-intermediate-representation"><a href="#lec2-intermediate-representation" class="header-anchor">#</a> Lec2 Intermediate Representation</h2> <p>源代码到机器代码需要经过词法分析、语法分析、语义分析，然后翻译成 IR，再生成机器代码，整个流程如下图所示：</p> <p><img src="/assets/img/lec2_compiler_process.f343b260.png" alt=""></p> <p>从图里可以看出，Static Analysis 一般是基于 IR 的，因为前面一些 trivial 的工作，比如语法解析之类，没必要重复做，至于为什么不使用 AST，主要是 IR 的通用性更好，更底层更接近机器代码，语言无关，而且还包含清晰的控制流信息。</p> <p>当然，IR 也有多种表示形式，比如常见的有 3AC 和 SSA，而课程用到的则是 Tai-e 的 IR。</p> <h3 id="control-flow-graph"><a href="#control-flow-graph" class="header-anchor">#</a> Control Flow Graph</h3> <p>虽然 Static Analysis 是基于 IR 的，但并不是直接在 IR 上进行分析，而是将 IR 构建成图模型，比如说这里要说的 Control Flow Graph。</p> <p>在 CFG 里，最小的单元是 Basic Block，每一个 Basic Block 需要保证只能一个入口和一个出口，即从 Basic Block 的第一条指令进入，从 Basic Block 的最后一条指令出去。</p> <p>那么，如何将 IR 切分成 Basic Block 呢？感觉这里有一点贪心的思想在里面，即在满足 Basic Block 条件的前提下，尽可能的使得每个 Basic Block 最大化。那么，实际上确定每个 Basic Block 的起始指令和结束指令就可以了。于是，可以得到如下的算法：</p> <p><img src="/assets/img/lec2_how_to_build_basic_blocks.7e4e2386.png" alt=""></p> <p>对应给出一个例子：
<img src="/assets/img/lec2_example_of_build_basic_block_from_ir.5b8d0698.png" alt=""></p> <p>CFG 既然是图，那么出了节点（Basic Block）之外，还需要边，思考该如何加边。首先，IR 到 CFG 的转换过程中，不应该损失信息，那么添加的边必然是原先在 IR 中就存在的，比如说条件跳转和顺序关系。实际上，差不多也就只有这两种情况了。</p> <p>Basic Block A 到 Basic Block B 之间有一条表，当前仅当如下两种情况：</p> <ol><li>A 的最后一条指令跳转（条件跳转或无条件跳转）到 B；</li> <li>B 紧跟在 A 之后，并且 A 的最后一条语句不是无条件跳转。</li></ol> <p>加上边的 CFG 如下图所示：
<img src="/assets/img/lec2_example_of_build_control_flow_graph.7a6a35be.png" alt=""></p> <p>可以看到，最终生成的 CFG 中多个两个 Basic Block，即 Entry 和 Exit，这是为了方便算法的实现。</p> <h2 id="lec3-4-data-flow-analysis-application"><a href="#lec3-4-data-flow-analysis-application" class="header-anchor">#</a> Lec3~4 Data Flow Analysis - Application</h2> <p>Static Analysis 的理论是比较抽象的，所以先举几个例子，近几节课主要研究 Data Flow Analysis，有如下经典的例子：</p> <ul><li>Reaching Definition Analysis</li> <li>Live Variable Analysis</li> <li>Available Expression Analysis</li></ul> <p>在那之前，先来搞明白什么是 Data Flow Analysis。</p> <p><img src="/assets/img/lec3_what_is_data_flow_analysis.8d9ea9c6.png" alt=""></p> <p>可知设计 DFA 可以从如下几个方面考虑：</p> <ul><li>data abstraction</li> <li>flow safe-approximation</li> <li>transfer function</li> <li>control-flow handling</li></ul> <p>在 DFA 中，会在每一个 Program Point 上附加一个一些数据，这些数据是在该 Program Point 处可以观测到的程序状态。</p> <h3 id="reaching-definition-analysis"><a href="#reaching-definition-analysis" class="header-anchor">#</a> Reaching Definition Analysis</h3> <p><img src="/assets/img/lec3_what_is_reaching_definition.64d502a4.png" alt=""></p> <p>通过在 CFG 的起始节点给所有变量一个不合法的 Definition，那么如果这个 Definition 可以流到变量被使用的地方，就说明出现了 use before define 的情况。</p> <p>从之前说的四个方面来讲解 Reaching Definition Analysis，即 data abstraction、flow safe-approximation、transfer function 和 control-flow handling。</p> <p>先来思考数据抽象是什么，不妨从分析的目的的角度来考虑，Reaching Definition Analysis 要分析的是某个 Definition 是否可以流到某个程序点处，那么，就可以定义一个位图，来标识某程序点处是否有其 Definition。</p> <p>然后再来考虑 flow safe-approximation，显然易知，只要有一条从 q 到 p 的路径，就应该认为 Definition Reach 了，所以这是 may analysis。</p> <p>接着考虑 transfer function，tansfer function 应用在 CFG 中的节点上，表示数据如何进行状态转换。在 Reaching Definition Analysis 的语境下，容易想到如下的 trafer function：</p> <p>$$
OUT[B] = gen_{B} \cup (IN[B] - kill_{B})
$$</p> <p>如何理解呢？这是一个 forward analysis，所以输出是 OUT[B] 自然不用讲。那么在每一个 Basic Block 中，状态如何转移？不妨举个例子，<code>d: v = x + 1</code>，那么这个时候变量 <code>v</code> 对应的 Definition 在其所在的 Basic Block 是 Reaching 的，同时该 Definition 还会让他处的关于 <code>v</code> 的 Definition 变得不 Reaching，这两部分分别对应 transfer function 里的 $gen_{B}$ 和 $kill_{B}$。同时，可以发现，$gen_{B}$ 和 $kill_{B}$ 都只是和当前 Basic Block 相关，换句话说，这些都是静态的在 DFA 进行之前就可以确定的。</p> <p>这么说还说太抽象，举个例子。
<img src="/assets/img/lec3_gen_b_and_kill_b.59a36384.png" alt=""></p> <p>最后来考虑 control-flow handling，control-flow 在 CFG 里的表现形式是 Basic Block 之间的交汇，比如上图里的 B2 和 B3 交汇于 B4 处，那么在 B4 处如何处理来自 B2 和 B3 的数据呢？从语义上考虑，无论是从 B2 流过来还是从 B3 流过来，都是有可能达到 B4 的，这也就是前面说的 may analysis，所以在 B4 处应该对交汇来的数据取并集，即：</p> <p>$$
IN[B] = \cup _{P ; a ; predecessor B} OUT[P]
$$</p> <p><img src="/assets/img/lec3_reaching_definition_control_flow_handling.250cd63e.png" alt=""></p> <p>至此就可以写出完整的迭代算法：</p> <p><img src="/assets/img/lec3_itertive_algorithm_of_reaching_definition.eef6472f.png" alt=""></p> <p>初看起来，这很像是 CFG 上的广度优先遍历，确实；也有些像是有限状态机（FSM），确实；也有点儿像布尔可满足性问题（SAT），确实。</p> <p>但无论说它像什么，都有以下三个问题尚未解决：</p> <ol><li>该算法一定会停止么？</li> <li>算法的停止状态一定只有一个么？如果多余一个，如何证明算法得到的那一个状态一定是最优的？</li> <li>若算法会停止，该如何找到这个状态呢？</li></ol> <p>这些稍后再说，先给出一个例子(建议手推一下)：</p> <p><img src="/assets/img/lec3_example_of_reaching_definition_start_state.8510466a.png" alt=""></p> <p><img src="/assets/img/lec3_example_of_reaching_definition_stop_state.f2c4132c.png" alt=""></p> <h3 id="live-variable-analysis"><a href="#live-variable-analysis" class="header-anchor">#</a> Live Variable Analysis</h3> <p><img src="/assets/img/lec3_waht_is_living_variable_analysis.de284deb.png" alt=""></p> <p>活跃变量分析给我的感觉很像是在分析 Variable 的 Non-Lexical Lifetime。这里稍微提一下，一般说 Lifetime，都是 Lexical Lifetime，即从声明开始一直到整个语句块结束，此时生命周期是严格按照词法中的作用域范围绑定的。这种设计看起来很简单，但在某些情况下会过于保守甚至严苛，以至于不实用，比如说在 Rust 里，考虑一个非常常见的使用数组切片的例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">capitalize</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token punctuation">[</span><span class="token keyword">char</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> data <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span><span class="token function">make_ascii_uppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> data <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">,</span> <span class="token char">'e'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> data<span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token char">'f'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    data
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> v <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{:#?}&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>调用<code>capitalize()</code> 时传参会创建一个临时的 <code>&amp;mut</code> 型引用，并在函数结束后销毁，因而返回 <code>foo</code> 函数里仍旧可以继续使用 <code>data</code> 对数据进行操作。</p> <p>但如果我手动的把传参创建的临时变量写出来呢？</p> <div class="language-diff line-numbers-mode"><pre class="language-diff"><code>diff --git a/src/main.rs b/src/main.rs
index ab972d0..5be7813 100644
<span class="token coord">--- a/src/main.rs</span>
<span class="token coord">+++ b/src/main.rs</span>
@@ -351,7 +351,8 @@ fn capitalize(data: &amp;mut [char]) {

<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">fn foo() -&gt; Vec&lt;char&gt; {
</span><span class="token prefix unchanged"> </span><span class="token line">    let mut data = vec!['a', 'b', 'c', 'e'];
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    capitalize(&amp;mut data[..]);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let slice = &amp;mut data[..];
</span><span class="token prefix inserted">+</span><span class="token line">    capitalize(slice);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    data.push('d');
</span><span class="token prefix unchanged"> </span><span class="token line">    data.push('f');
</span><span class="token prefix unchanged"> </span><span class="token line">    data
</span></span></code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>那很抱歉，如果按照 Lexical Lifetime 来分析的话，可变引用 <code>slice</code> 的生命周期直到 <code>foo()</code> 函数最后才结束，那么就同时存在多个可变引用了，因而无法通过编译。</p> <p>这看起来没问题，但用起来是真难受，明明只是把 <code>slice</code> 当作临时变量，并且显式写出来了，编译器为啥不能聪明一点？</p> <p>这个例子也许会说算了算了，不把 <code>slice</code> 写出来不就好了，那，再看下面这个例子：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">proces_or_default</span><span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">:</span> <span class="token class-name">Default</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>map<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token class-name">K</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">match</span> map<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">process</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>定义一个函数，如果 HashMap 里存在相应的 entry 就进行操作，否则插入默认值。看起来很好，但很遗憾的是，无法通过编译（注，HashMap 的 API 在 Rust 2018 有了一些改动，但这不是这里要讨论的问题所在）。因为编译器认为调用 <code>map.get_mut(&amp;key)</code> 的时候，产生了一个临时的执行 map 的 <code>&amp;mut</code> 引用，并且返回值也包含了一个引用，且返回的引用的生命周期不比参数的生命周期短，而参数的生命周期显然是整个函数体，那么第 5 行通过数据的持有者 map 来修改数据会不通过，即同时存在了两个可变引用。</p> <p>为了绕过 Lexical Lifetime Check，需要写成类似如下的形式：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">proces_or_default</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'m</span><span class="token punctuation">,</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">:</span> <span class="token class-name">Default</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>map<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'m</span> <span class="token keyword">mut</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token class-name">K</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'m</span> <span class="token keyword">mut</span> <span class="token class-name">V</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> map<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">match</span> map<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Some</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">,</span>
            <span class="token class-name">None</span> <span class="token operator">=&gt;</span> <span class="token macro property">unreachable!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    map<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>实际上是通过 <code>if</code> 缩小了生命周期，当然，目前版本的 HashMap 已经好用很多的了，可以很方便的写出：</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">proces_or_default</span><span class="token operator">&lt;</span><span class="token lifetime-annotation symbol">'m</span><span class="token punctuation">,</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">:</span> <span class="token class-name">Default</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>map<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'m</span> <span class="token keyword">mut</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token class-name">K</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">'m</span> <span class="token keyword">mut</span> <span class="token class-name">V</span> <span class="token punctuation">{</span>
    map<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or_insert_with</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token class-name">V</span><span class="token punctuation">::</span><span class="token function">default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这反映出至少就 Rust 而言，基于 AST 做生命周期分析是一件吃力不讨好的事情，因而 Rust 的生命周期目前是基于 IR 的 Non-Lexical Lifetime。</p> <p>扯远了，继续说回 Live Variable Analysis。同样从上面提到的四个方面来分析如何设计算法。这里不再详述，直接给出。需要注意的是，这次是 forward may analysis。</p> <p><img src="/assets/img/lec3_transfer_function_of_live_variable_analysis.797b4a26.png" alt=""></p> <p><img src="/assets/img/lec3_itertive_algorithm_of_live_variable.d3a609b8.png" alt=""></p> <p>同样的给出一个例子：</p> <p><img src="/assets/img/lec3_example_of_live_variable_start_state.7e231447.png" alt=""></p> <p><img src="/assets/img/lec3_example_of_live_variable_stop_state.be498c29.png" alt=""></p> <h3 id="available-expression-analysis"><a href="#available-expression-analysis" class="header-anchor">#</a> Available Expression Analysis</h3> <p><img src="/assets/img/lec3_what_is_available_expression_analysis.e73bbbe7.png" alt=""></p> <p>这个我感觉是在分析是否能重用上一次表达式的计算结果，那么就需要表达式中的变量在两次计算之间没有被重新定义或者赋值。</p> <p>这一次和之前的略有不同，是一个 forward must analysis，因为重用计算结果需要确保在所有可能的路径上都是成立的才能进行优化，这使得在初始化的时候，会有些不同。</p> <p>同样的，直接给出算法。</p> <p><img src="/assets/img/lec3_transfer_function_of_available_expression_analysis.f79d7d7a.png" alt=""></p> <p><img src="/assets/img/lec3_itertive_algorithm_of_available_expression.29f755ea.png" alt=""></p> <p>同样的，给出例子：</p> <p><img src="/assets/img/lec3_example_of_available_expression_start_state.bd7da095.png" alt=""></p> <p><img src="/assets/img/lec3_example_of_available_expression_stop_state.2a798ffb.png" alt=""></p> <h3 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h3> <p><img src="/assets/img/lec3_summary.be322d80.png" alt=""></p> <h2 id="lec5-6-data-flow-analysis-foundations"><a href="#lec5-6-data-flow-analysis-foundations" class="header-anchor">#</a> Lec5~6 Data Flow Analysis Foundations</h2> <h3 id="fix-pointer-view-of-dfa"><a href="#fix-pointer-view-of-dfa" class="header-anchor">#</a> Fix Pointer View of DFA</h3> <p>换一个视角来思考上一讲的迭代算法：</p> <p><img src="/assets/img/lec4_fix_pointer_view_of_itertive_alogrithm.3d75013f.png" alt=""></p> <p>会发现迭代算法就是在给定状态下求不动点。</p> <p>那么在前面 Reaching Definition Analysis 哪里遗留的三个问题就可以换一种更明确的表述了：</p> <ol><li>迭代算法是否可以达到不动点以终止，或者说问题是否总是有解？</li> <li>如果存在不动点，那么是否只有一个？如果有多个，如何保证算法得到的一定是精度最好的那一个？</li> <li>迭代算法何时才能到达不动点？</li></ol> <p>此时可以解决这三个问题了，虽然又到了<s>枯燥</s>有趣的数学时间了。</p> <h3 id="partial-order"><a href="#partial-order" class="header-anchor">#</a> Partial Order</h3> <p>定义偏序集（poset）为一个二元组 $(P,  \sqsubseteq )$，其中 $ \sqsubseteq $ 定义了一个 $P$ 上的偏序关系，当然其本身是一个二元关系，并且 $ \sqsubseteq $ 有如下性质：</p> <ol><li>自反性（$\forall x \in P,x \sqsubseteq x$）</li> <li>反对称性（$\forall x,y \in P,x \sqsubseteq y \wedge y \sqsubseteq x \Rightarrow x = y$）</li> <li>传递性（$\forall x,y,z \in P,x \sqsubseteq y \wedge y \sqsubseteq z \Rightarrow x \sqsubseteq z$）</li></ol> <p>传递性其实是比较容易满足的，主要还是自反性和反对称性。比如说整数集上的 $\le$ 定一个了一个偏序关系，但 $\lt$ 并不是，因为不满足自反性。</p> <p>既然是一个排序关系，那么自然会想到是否存在最大最小值之类的问题，给出如下定义：</p> <p><img src="/assets/img/lec4_definition_of_upper_bound_and_lower_bound.6edc6a33.png" alt=""></p> <p>即上界（UB）、下界（LB）、上确界（LUB）、下确界（GLB）。</p> <p>当然，并非所有的 poset 都有这四个边界，比如下面的例子就没有 glb。</p> <p><img src="/assets/img/lec4_example_of_poset_without_glb.d35d2a8b.png" alt=""></p> <p>又合理的想到，偏序关系里是否存在一些特殊的值得研究的情况呢？还真有，就是下面要说的 Lattice。</p> <h3 id="lattice"><a href="#lattice" class="header-anchor">#</a> Lattice</h3> <p>在 poset 里找出一些比较特殊的，即对 poset 里的任意两个元素来说，LUB 和 GLB 都成立的话，就称 $(P, \sqsubseteq)$ 构成一个 Lattice。</p> <p>Lattice 的例子比如定义在整数集合上的 $\le$，前面说了构成偏序关系，又任意两个元素 $a,b$ 的 LUB 可以认为是 <code>Max(a, b)</code>，而 GLB 可以认为是 <code>Min(a, b)</code>。</p> <p>可以想像的到，如果把 Lattice 画出来，应该都是类似下面的形状，即从某一个特定的 source 一直按照某一个特定的方向流入到某一个特定的 destination。其中，特定的方向实际上就是偏序关系 $\sqsubseteq$，特定的 source 是保证 LUB 的存在，记作 top（T），特定的 destination 则是保证 GLB 的存在，记作 bottom（$\perp$）。</p> <p><img src="/assets/img/lec4_example_of_lattice_shape.a81b5aac.png" alt=""></p> <p>说错哩，前面一直在说 complete lattice，这是 lattice 里最特殊的情况，像上面的图里面，已经不是 lattice 定义里的分析元素之间的关系了，变成了分析子集之间的关系。但不算太重要，知道 complete lattice 够用了。</p> <p>另外，将 Product Lattice 定义为两个 Latiice 之间的笛卡尔积，易知，complete lattice 的 product 仍然是 complete lattice。</p> <p>至此，可以用 Lattice 来建模 DFA，将 DFA 定义为三元组 $(D, L, F)$。</p> <p><img src="/assets/img/lec4_data_flow_analysis_framework_via_lattice.523219e9.png" alt=""></p> <p>那么，就可以将 DFA 看作是在 lattice 上迭代的应用 trafer function 和 control-flow handling。</p> <h3 id="fix-point-theorem"><a href="#fix-point-theorem" class="header-anchor">#</a> Fix Point Theorem</h3> <p>前面只是将问题换了一个论域，但并未解决任何一个问题，有一种浅显的感觉，答案和单调性有关，确实是：</p> <p><img src="/assets/img/lec4_monotonicity_and_fix_point_theorem.77e4a591.png" alt=""></p> <p><s>这里的单调性怎么这么像协变的定义啊</s></p> <p>不动点原理可以用鸽笼来简单的证明：</p> <p><img src="/assets/img/lec4_proof_of_fixed_point_theorem.7812a2c1.png" alt=""></p> <p>至此，可以将 DFA 和不动点原理关联起来。</p> <p><img src="/assets/img/lec4_relate_iterative_algoritm_to_fixed_point_theorem.5249f748.png" alt=""></p> <p>那么，现在还需要解决的事情就是证明 trafer function 以及 control-flow handling 的单调性。</p> <p>transfer function 的单调性是好说明的，比如 Reaching Definition Analysis 里的 transfer function：</p> <p>$$
OUT[B] = gen_{B} \cup (IN[B] - kill_{B})
$$</p> <p>$gen_{B}$ 和 $kill_{B}$ 都是固定的，而且是取并集，那么只存在 $0 \to 1$ 的转变，即满足反对称性。</p> <p>至此，前两个问题通过不动点理论可以得解，即算法存在不动点，虽然不动点的数量可能不止一个，但可以保证求得的是最优的（即最大不动点或最小不动点）。</p> <p>那么，算法何时停止呢？或者说算法的时间复杂度是怎样的。</p> <p>因为每一次都是在 lattice 的一次状态转移，那么对于高度为 $H$ 的 lattice 来说，每一个 program point 最多进行 $H$ 次状态转移，若记 program point 的数量为 $k$，则算法最坏情况下的时间复杂度为 $k * H$。</p> <p>至此，三个问题得解。</p> <p><img src="/assets/img/lec4_answer_to_the_three_question.9152f953.png" alt=""></p> <h3 id="lattice-view-of-may-and-must-analysis"><a href="#lattice-view-of-may-and-must-analysis" class="header-anchor">#</a> Lattice View of May and Must Analysis</h3> <p>还有一个前面没有说清楚的问题，即 May Analysis 和 Must Analysis 的区别。</p> <p><img src="/assets/img/lec4_lattice_view_of_may_and_must_analysis.37f174d1.png" alt=""></p> <p>上面对比图很直观的说明了问题，不管是 May Analysis 还是 Must Analysis，都是从 unsafe state 往 Safe but Useless state 转移，中途在不动点出停下来。那么，根据语义找到 Safe but Useless state，另一边就是迭代的起始状态了。</p> <p>拿 Live Variable Analysis 来说，这是一个 may backward analysis，在某一点处 Safe but Useless state 是什么呢？显然是所有变量都可能存活，即 top，其对应的状态是所有变量都不可能存活，即 bottom，而 may analysis 是从 bottom 到 top 的转移，所以就可以确定初始状态了。</p> <h3 id="meet-over-all-path-mop"><a href="#meet-over-all-path-mop" class="header-anchor">#</a> Meet Over All Path(MOP)</h3> <p>前面说迭代算法像图的广度优先遍历，那么自然会好奇是否存在深度优先遍历。是有的，即这里说的 MOP。</p> <p><img src="/assets/img/lec4_meet_over_all_path_solution.b5c88180.png" alt=""></p> <p>那么，两种方法最终的结果相同么？如果不相同，谁的精度好一些？</p> <p><img src="/assets/img/lec4_compare_iterative_algorithm_and_mop.bf84776b.png" alt=""></p> <p>上图是按照 may analysis 得到的 Ours is less precise than MOP 的结论，因为 $MOP \sqsubseteq Ours$ 表明 MOP 在 lattic 上更接近 bottom，也即精度更好。</p> <p>但是当 transfer function 是可分配的时候，两者在精度上是没有区别的。</p> <p>而前面的几个例子都是集合的交并操作，这些都是满足分配律的，因而前面的例子两种方式的精度是相同的。</p> <h3 id="constant-propagation"><a href="#constant-propagation" class="header-anchor">#</a> Constant Propagation</h3> <p>前面的例子中，transfer function 都是满足分配律的，下面介绍不满足分配律的例子，即 Constant Propagation。</p> <p><img src="/assets/img/lec4_what_is_constant_propagation.903dedd1.png" alt=""></p> <p>Constant Propagation 研究的是在 Program Point P 这一点变量 x 的值是否是一个恒定的常量。</p> <p>然后来定义 lattice，Domain 的话，就是 UNDEF、C、NAC 三种情况。</p> <p><img src="/assets/img/lec4_constant_propagation_on_lattice.c57a38a8.png" alt=""></p> <p><img src="/assets/img/lec4_transer_function_of_constant_propagation.6152c833.png" alt=""></p> <p>随便找个例子，用反正法证明 Constant Propagation 的 transfer function 不满足分配律：</p> <p><img src="/assets/img/lec4_constant_propagation_nondistributivity.eba26f55.png" alt=""></p> <h3 id="worklist-alogirithm"><a href="#worklist-alogirithm" class="header-anchor">#</a> WorkList Alogirithm</h3> <p>在前面手推状态转移的时候，会发现其实很多情况是不需要重复计算的，比如输入不变的情况下，输出一般都是不变的，因而就有了对迭代算法的优化，引入 WorkList 的概念。</p> <p>比较好理解，就直接那前面 Available Expression 的例子来说明吧。</p> <p><img src="/assets/img/lec4_review_iterative_algorithm_for_may_forward_analysis.be589656.png" alt=""></p> <p><img src="/assets/img/lec4_worklist_algorhtm_of_forward_may_analysis.dde6d0a0.png" alt=""></p> <h2 id="lec7-interprocedural-analysis"><a href="#lec7-interprocedural-analysis" class="header-anchor">#</a> Lec7 Interprocedural Analysis</h2> <p>前面的几个例子，都只是分析了代码片段，或者说都没有跨函数分析，像在 Constant Propagation Analysis 的时候，为了保守期间，只要是函数调用，都认为是 NAC，这会对精度造成很大的损失。因而有了 Interprocedural Analysis 来进行函数间调用分析。</p> <p>Interprocedural Analysis 是需要 Call Graph 的，对于 OOPL 来说，构建 Call Graph 有四种方法：</p> <ol><li>Class hierarchy analysis(CHA)</li> <li>Rapid type analysis(RTA)</li> <li>Variable type analysis(VTA)</li> <li>Pointer analysis(k-CFA)</li></ol> <p>速度方面：CHA &gt; RTA &gt; VTA &gt; k-CFA
精度方面：k-CFA &gt; VTA &gt; RTA &gt; CHA</p> <h3 id="function-call-in-java"><a href="#function-call-in-java" class="header-anchor">#</a> Function Call In Java</h3> <p>因为主要是针对 Java 进行静态分析，那么首先需要先了解 Java 里存在的几种函数调用：</p> <ol><li><p>Static Call</p> <p>invokestatic，主要是调用静态方法的，所以在编译期就可以决议出目标方法。</p></li> <li><p>Special Call</p> <p>invokespacial，主要是调用构造方法、私有实例方法、父类实例方法，同样的也可以在编译期决议出目标方法。</p></li> <li><p>Virtual Call</p> <p>invokevirtual/invokeinterface，其余的实例方法都属于此列，这也是所谓的多态，因而需要在运行期决议目标方法。</p></li></ol> <h3 id="method-dispatch-for-virtual-call"><a href="#method-dispatch-for-virtual-call" class="header-anchor">#</a> Method Dispatch for Virtual Call</h3> <p>主要分析的是编译期无法决议出的 Virtual Call，首先 Dispatch 需要哪些信息。首先，需要函数签名，其次，如果是 instance method，还需要有调用对象，也就是 receiver object。Java 里的函数签名有如下记法：</p> <p><img src="/assets/img/lec5_signature_of_method_in_java.6b2cc2bd.png" alt=""></p> <p><img src="/assets/img/lec5_method_dispatch_of_virtual_calls.332b1f40.png" alt=""></p> <p>也就是说，最先在自己的方法列表中查找，查找不到就到父类中找。举个例子：</p> <p><img src="/assets/img/lec5_example_of_dispatch_virtual_call.c36cb42f.png" alt=""></p> <p>那么，现在的问题就变成了构建 Call Graph。</p> <h3 id="class-hierarchy-analysis"><a href="#class-hierarchy-analysis" class="header-anchor">#</a> Class Hierarchy Analysis</h3> <p><img src="/assets/img/lec5_what_is_classs_hierarchy_analysis.a28eb109.png" alt=""></p> <p>CHA 是基于类继承信息的，会使用 receiver variable 的 declared type 做决议，也就是说使用其静态类型。决议的实现很简单，对于 static call 直接返回方法签名；对于 special call，会拿出 signature 中的 class type 去 Dispatch；对于 virtual call，则会对于调用点处的变量的声明类型已经该声明类型的所有子类型中去 Dispatch。算法的伪代码如下：</p> <p><img src="/assets/img/lec5_algorithm_of_call_resolution_of_cha.ab95f140.png" alt=""></p> <p>对于 static call 和 special call 没什么好说的，无论在哪个算法里都差不多。重点在 virtual call 的处理中，从代码中可以知道，直接把类型信息擦除了，会决议出所有可能被调用到的方法（自身类型以及所以该类型的子类型）。</p> <p>举个例子：</p> <p><img src="/assets/img/lec5_example_of_cha.1ff44b38.png" alt=""></p> <p>// TODO</p> <p>这太奇怪了，为啥 <code>Resolve(a.foo())</code> 会是这么多啊，不应该只去 <code>A</code>、<code>B</code> 这两个类里取 Dispatch 么？不会这里的 subclass 包括子类的子类吧？</p> <p>CHA 速度快，但不精准，一般也就 IDE 里可能会用用。在用 CHA 构建 Call Graph 的时候，一般会将 <code>main</code> 之类的入口方法作为起始。</p> <p>看一个例子：</p> <p><img src="/assets/img/lec7_example_of_build_call_graph_use_cha_start_state.b7bdc8c3.png" alt=""></p> <p><img src="/assets/img/lec7_example_of_build_call_graph_use_cha_stop_state.03ed070b.png" alt=""></p> <p>容易想到，CHA 跑完之后的不可达代码实际上也是 dead code。</p> <h3 id="interprocedural-control-flow-graph"><a href="#interprocedural-control-flow-graph" class="header-anchor">#</a> Interprocedural Control Flow Graph</h3> <p>有了 Call Graph 之后，就可以将 CFG 升级到 ICFG 了，需要在 CFG 的基础上添加 call edge 和 return edge。需要注意的是，call-to-return edge 不需要删除，因为 call edge 一般只用来传递函数的参数，而 caller 中还有其他的数据，如果删掉了 call-to-return edge 的话，这部分数据也需要经由 call edge 流向 callee，最终经由 return edge 流回 caller，这实际上不必要的开销。只要在 caller 处将流向 callee 参数的那部分数据 kill 掉即可，不会出现多条路径导致数据重复或者冲突的情况出现的。</p> <p><img src="/assets/img/lec7_example_of_iterprocedural_control_flow_graph.111914b3.png" alt=""></p> <h3 id="interprocedural-constant-propagation"><a href="#interprocedural-constant-propagation" class="header-anchor">#</a> Interprocedural Constant Propagation</h3> <p><img src="/assets/img/lec7_example_of_interprocedural_constant_propagation.f259b97f.png" alt=""></p> <p><img src="/assets/img/lec7_example_of_intraprocedural_constant_propagation.58979476.png" alt=""></p> <p>可以看到 Interprocedural Analysis 因为没有擦除函数调用信息，因而精度更高。</p> <h2 id="lec8-pointer-analysis"><a href="#lec8-pointer-analysis" class="header-anchor">#</a> Lec8 Pointer Analysis</h2> <p><img src="/assets/img/lec8_problem_of_cha.b0c81111.png" alt=""></p> <p>前面提到了 CHA 来构建 Call Graph，精度并不好，哪怕是 IDE 这种场景，如果尝试跳到某个 instance method 里，出现一串可能的 target method，体验并不好，比如上面 <code>n.get()</code> CHA 会给出 <code>Zero::get()</code>、<code>One::get()</code>、<code>Two::get()</code> 三个结果。</p> <p><img src="/assets/img/lec8_what_is_pointer_analysis.ce4fae0a.png" alt=""></p> <p>指针分析分析的是某一个内存位置可以被哪些指针（这里的指针并非是 C++ 里狭义上指针的概念，对 Java 而言，指针可以是 variable、instance field、array 等等）指向。</p> <p><img src="/assets/img/lec8_example_of_simple_pointer_analysis.7860375e.png" alt=""></p> <p>虽然看起来有点儿像 Alias Analysis，但其实是不一样的，Pointer Analysis 侧重于分析指针可以指向哪些对象，而 Alias Analysis 侧重于分析是否有两个指针指向了相同的对象。</p> <p>Pointer Analysis 的应用：</p> <ol><li>生成基础的信息，比如 Call Graph 和 Aliases 等；</li> <li>编译优化，比如虚函数调用内联等；</li> <li>安全分析，比如 Information Flow analysis</li> <li>等等等等</li></ol> <h3 id="key-factor-in-pointer-analysis"><a href="#key-factor-in-pointer-analysis" class="header-anchor">#</a> Key Factor in Pointer Analysis</h3> <p>感觉上下文分析都做 heap abstraction 了，真的还算是 static analysis 么？已经算是在 Pointer Analysis 的环境里运行了吧？</p> <p><img src="/assets/img/lec8_key_factors_in_pointer_analysis.54cf1aa8.png" alt=""></p> <p>课程里主要设计的是红色标出的这些：</p> <p><img src="/assets/img/lec8_what_conert_in_this_course_about_pointer_analysis.fde84ca0.png" alt=""></p> <h3 id="heap-abstraction"><a href="#heap-abstraction" class="header-anchor">#</a> Heap Abstraction</h3> <p>Heap Abstraction 需要对程序运行时的堆进行建模，一个首要的问题是遇到下面类似的情况，仍旧可以正常分析：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>也就是说程序动态运行时候创建的对象数量在静态分析的时候是无法感知的，那么如何确保抽象对象的有穷性。</p> <h4 id="allocation-site-abstraction"><a href="#allocation-site-abstraction" class="header-anchor">#</a> Allocation-Site Abstraction</h4> <p>一个容易想到的方案是进程是程序的一次执行，虽然无法感知进程的信息，但是程序是静态的，那么对于每一个 Allocation-Site 都创建一个 abstract object，就可以保证其有穷性了。</p> <p><img src="/assets/img/lec8_what_is_allocation_site_abstraction.81b65ae4.png" alt=""></p> <h3 id="context-sensitivity"><a href="#context-sensitivity" class="header-anchor">#</a> Context Sensitivity</h3> <p>简单来说就是否忽略函数调用时候的上下文信息。</p> <p><img src="/assets/img/lec8_what_is_context_sensitivity.00477b58.png" alt=""></p> <h3 id="flow-sensitivity"><a href="#flow-sensitivity" class="header-anchor">#</a> Flow Sensitivity</h3> <p>简单来说就是是否关注指令的有序性，或者说指令的顺序是否在分析的范围内。</p> <p><img src="/assets/img/lec8_what_is_flow_sensitivity.be8d8186.png" alt=""></p> <h3 id="analysis-scope"><a href="#analysis-scope" class="header-anchor">#</a> Analysis Scope</h3> <p>Analysis Scope 是说分析的范围是哪些，是直接全程序分析，还是需求驱动的仅仅对需要的部分进行分析。一般来说，都会进行全程序分析，虽然一次全程序分析的速度是要慢于需求驱动分析的，但是全程序分析的结果是可以重复使用的。</p> <p><img src="/assets/img/lec8_what_is_analysis_scope.0b756a85.png" alt=""></p> <h3 id="concerned-statement"><a href="#concerned-statement" class="header-anchor">#</a> Concerned Statement</h3> <p>在进行 Pointer Analysis 的时候，并非所有的指令都要去分析，比如 <code>if/else</code>、<code>switch case</code> 这些控制流语句，并不会影响指针， 需要关注是的只有那些能影响到指针的语句。</p> <p><img src="/assets/img/lec8_pointers_in_java.aef18e27.png" alt=""></p> <p>首先需要明确 Java 里的 Pointer 有哪些。主要是上图里的四种。其中 Static Field 在处理的时候和 Local Variable 基本相同，而 Array element 因为无法静态感知其数组元素个数，因而会将其看作只有一个只有一个 field 的对象，那么此时的情况和 instance field 是相同的。</p> <p>因而，最终需要关注的 Pinter 只有如下两类：</p> <ol><li>Local Variable: x</li> <li>Instance Field: x.f</li></ol> <p>说完了 Pointer 的概念，还得说一说有哪些语句可能会影响到指针，在排除控制流语句之后，大概剩下如下五种语句：</p> <p><img src="/assets/img/lec8_which_statement_can_affect_pointer_in_java.553a25f6.png" alt=""></p> <h2 id="lec9-10-pointer-analysis-foundations"><a href="#lec9-10-pointer-analysis-foundations" class="header-anchor">#</a> Lec9~10 Pointer Analysis Foundations</h2> <p>再看一眼上一讲说过的会影响到指针的语句:</p> <p><img src="/assets/img/lec8_which_statement_can_affect_pointer_in_java.553a25f6.png" alt=""></p> <p><img src="/assets/img/lec9_domain_and_notations_of_context_insensitive_pointer_analysis.bb67185d.png" alt=""></p> <p><img src="/assets/img/lec9_rules_of_context_insensitive_pointer_analysis.cefe18de.png" alt=""></p> <p><s>看到推导式形式化方法死去的记忆开始痛击我。</s></p> <h3 id="implement-pointer-analysis"><a href="#implement-pointer-analysis" class="header-anchor">#</a> Implement Pointer Analysis</h3> <p><img src="/assets/img/lec9_how_to_implement_pointer_analysis.9b808952.png" alt=""></p> <h3 id="pointer-flow-graph"><a href="#pointer-flow-graph" class="header-anchor">#</a> Pointer Flow Graph</h3> <p>Pointer Analysis 是基于 PFG 的，PFG 上的节点是 Pinter，而节点之间的边表示指针的流向关系。</p> <p><img src="/assets/img/lec9_definition_of_pointer_flow_graph.b321afe1.png" alt=""></p> <p><img src="/assets/img/lec9_edges_in_pointer_flow_graph.236d8df1.png" alt=""></p> <p><img src="/assets/img/lec9_example_of_pointer_flow_graph.7ba1da54.png" alt=""></p> <p>一个问题是，在上面的图中，如果没有后面两条语句，那么变量 <code>c</code> 和其 field f 如何建立关联呢？想不明白。</p> <p>Pointer Analysis 里的 PFG 是动态建立的，不像之前 Data Flow Analysis 里的 CFG 是在初始的时候就由 IR 完整构建出来的。</p> <p><img src="/assets/img/lec9_build_pointer_flow_graph_and_propagate_points_to_information_on_pfg.624b3c89.png" alt=""></p> <h3 id="pointer-analysis-algorithm-without-method-call"><a href="#pointer-analysis-algorithm-without-method-call" class="header-anchor">#</a> Pointer Analysis Algorithm Without Method Call</h3> <p><img src="/assets/img/lec9_worklist_of_context_insensitive_pointer_analysis.ecb1699a.png" alt=""></p> <p><img src="/assets/img/lec9_algorithm_for_context_insensitive_pointer_analysis.71d0fe52.png" alt=""></p> <p><img src="/assets/img/lec9_differential_propagation_of_pointer_analysis.47e31654.png" alt=""></p> <p>这里注意一下，在 propagate point to information 的时候，是进行的增量传播，而非全量传播。首先明确 <code>pt(n)</code> 是单调的，只会往里增加，而不会减少。其次，在 <code>AddEdge(s, t)</code> 的时候，是进行的全量传播，会将 <code>&lt;t, pt(s)&gt;</code> 加入到 WorkList 里面，可以认为将 <code>pt(s)</code> 传递到了非联通分量里面。最后，从 WorkList 里取出数据的时候，用 Propagate 增量传播的时候，如果是刚刚新加的边，那么增量其实就是全量，而对于已联通的节点，其传递的则是增量信息（当然，由于流不敏感，且没有规定以何种顺序从 WorkList 里取 entry，有可能这时候节点还没联通，仍旧传播全量信息）。但不管怎么说，增量传播性能总是要好于全量传播的。</p> <p><img src="/assets/img/lec9_example_of_context_insensitive_pointer_analysis_start_state.b83a2349.png" alt=""></p> <p><img src="/assets/img/lec9_example_of_context_insensitive_pointer_analysis_stop_state.e7a53950.png" alt=""></p> <h3 id="pointer-analysis-algorithm-with-method-call"><a href="#pointer-analysis-algorithm-with-method-call" class="header-anchor">#</a> Pointer Analysis Algorithm With Method Call</h3> <p>前面说了影响指针的语句有如下五种：</p> <ol><li>New</li> <li>Aasign</li> <li>Load</li> <li>Store</li> <li>Method Call</li></ol> <p>前面介绍了没有 Method Call 情况下的上下文不敏感的指针分析，现在加入对 Method Call 的处理。</p> <p>通过前面对于 Pointer Analysis Alogirithm 的了解，应该有这么一种感觉，Method Call 无非也是在 PFG 上多了些连接节点的规则。</p> <p>那么，来看看 Method Call Rule 吧，当然，Method Call 必然设计 Interprocedural Analysis，所以是需要 Call Graph 的，而 Call Graph 的构建，之前说了不太精准的 CHA，下面会介绍基于 Pointer Analysis 构建 Call Graph，会看到构建 Call Graph 和构建 Pointer to information 是同时进行的。</p> <p><img src="/assets/img/lec9_pointer_analysis_in_the_presence_of_method_invocations.4f60bf8d.png" alt=""></p> <p><img src="/assets/img/lec9_rule_of_method_call_in_pointer_analysis.fa5f76b2.png" alt=""></p> <p>可以看到 Method Call Rule 主要做了四件事：</p> <ol><li>Dispatch</li> <li>传 receiver object</li> <li>传参数</li> <li>传返回值</li></ol> <p>至于为什么不在 PFG 里加入 $x \to m_{this}$ 这条边，我是这么这么理解的，如果加了边，那么可以理解为又是一次 Context InSensitive，并且会将此处的精度损失在整个 PFG 上传播，而每次传过去，就很像是在 Call-Site Sensitive。</p> <p>有了 Method Call 之后的 Pointer Analysis 算法如下：</p> <p><img src="/assets/img/lec9_pointer_analysis_algorithm_with_method_call.b8579906.png" alt=""></p> <p>之前因为没有 Method Call，实际上是 Intraprocedural Analysis，所以在算法的输入是某个 Method 的语句的集合，那么初始化的时候，将这个 Method 的 New 和 Assign 拿出来初始化就好。但加入 Method Call 之后，算法的输入就是某个函数了，而后面会跳到其他函数来分析，因而需要将对 New 和 Assign 的处理抽出来，单独封装成一个函数，也就是图里的 <code>AddReachable(m)</code>。</p> <p>对于 Method Call 的处理，就是 ProcessCall 了，会找出语句集合里每一次和 x 相关的 Method Call，去做 Dispatch，并将 $m_{this}$ 加入到 WorkList 里。同时，如果从 Call Graph 里没有这条边（$l \to m$），会添加进去，相应的，将 m 标记为可达方法，并处理其中的 New 和 Assign。</p> <p>算法的主体部分倒是没有什么太大的差别。</p> <p>看一个例子吧。</p> <p><img src="/assets/img/lec9_example_of_pointer_analysis_with_method_call_start_state.b9bb1765.png" alt=""></p> <p><img src="/assets/img/lec9_example_of_pointer_analysis_with_method_call_stop_state.23c5eb1e.png" alt=""></p> <h2 id="lec11-12-pointer-analysis-context-sensitivity"><a href="#lec11-12-pointer-analysis-context-sensitivity" class="header-anchor">#</a> Lec11~12 Pointer Analysis Context Sensitivity</h2> <p><img src="/assets/img/lec11_problem_of_context_insensitive_pointer_analysis.1e8ef8ab.png" alt=""></p> <p>Context InSensitivity Pointer Analysis 处理 Method Call 的时候，不会维护函数间调用的上下文，比如上图里的 <code>x = id(n1);</code> 和 <code>y = id(n2)</code>，是无法区分多次对于同一个函数的调用的，哪怕是不同的 object 和不同的 parameter。</p> <p>可以发现，问题出在多次调用了同一个方法，使得原本分离的数据流合并到了一起。一个合理的设想是，能不能在每次 Method Call 的时候，将 Method 拷贝一份，这样就可以做到限制每个 Method Call 只发生一次了，这就是我对 Context Sensitivity 的理解。这有点儿像是对 Call Stack 的抽象。</p> <p><img src="/assets/img/lec11_what_is_cloning_based_context_sensitivity.90ba112e.png" alt=""></p> <p><s>这么看起来，Rust 的生命周期标准和这里的 Context 确实是不一样的。</s></p> <p><img src="/assets/img/lec11_example_of_context_sensitive_pointer_analysis.7dfec206.png" alt=""></p> <h3 id="context-sensitive-heap"><a href="#context-sensitive-heap" class="header-anchor">#</a> Context Sensitive Heap</h3> <p>容易想到，Method Call 的时候采用 Cloning-Based Context Sensitivity 的时候，会一起连带着将 Method 里的 Heap 一起复制一份，这样才能将数据流完全分离开来，这即使 Context Sensitive Heap。</p> <p><img src="/assets/img/lec11_example_of_context_sensitive_heap.cd8f2fce.png" alt=""></p> <p>学到这里，应该可以有种直觉，C.I. + C.S. Heap 并不能提高精度，事实确实如此。</p> <p><img src="/assets/img/lec11_example_of_context_insensitive_and_context_sensitive_heap.8b08e1be.png" alt=""></p> <h3 id="context-sensitive-pointer-analysis-rule"><a href="#context-sensitive-pointer-analysis-rule" class="header-anchor">#</a> Context Sensitive Pointer Analysis Rule</h3> <p><img src="/assets/img/lec11_domain_and_notations_of_context_insensitive_pointer_analysis.08039397.png" alt=""></p> <p><img src="/assets/img/lec11_rules_of_context_sensitive_pointer_analysis.8c9b0e67.png" alt=""></p> <p><img src="/assets/img/lec11_rules_2_of_context_sensitive_pointer_analysis.6d943f93.png" alt=""></p> <p>基础的四条 C.S. Rule 和 C.I. Rule 的差别仅仅在于是否有上下文信息。</p> <p>真正有区别的是 Method Call Rule，里面多了选择上下文信息的操作。</p> <p><img src="/assets/img/lec11_rules_of_method_call_in_context_sensitive_pointer_analysis.ef7b4395.png" alt=""></p> <p><img src="/assets/img/lec11_rules_2_of_method_call_in_context_sensitive_pointer_analysis.cda95a14.png" alt=""></p> <h3 id="context-sensitive-pointer-analysis-algorithm"><a href="#context-sensitive-pointer-analysis-algorithm" class="header-anchor">#</a> Context Sensitive Pointer Analysis Algorithm</h3> <p><img src="/assets/img/lec11_how_to_implement_context_sensitive_pointer_analysis.90e76a6f.png" alt=""></p> <p><img src="/assets/img/lec11_pointer_flow_graph_with_cs.c903ce31.png" alt=""></p> <p><img src="/assets/img/lec11_context_sensitive_pointer_analysis_algorithm.f6360e9a.png" alt=""></p> <p>可以看一下和 C.I. Algorithm 的对比，确实只是在 Method Call 的时候多个 Select 操作，已经其他参数的地方上下文的不同。实际上，C.I. 是 C.S. 的特例，即 Select 选择出来的上下文永远为空，所有参数的上下文也为空。</p> <p><img src="/assets/img/lec11_context_insensitive_pointer_analysis_algorithm.c53559c1.png" alt=""></p> <h3 id="context-sensitive-variants"><a href="#context-sensitive-variants" class="header-anchor">#</a> Context Sensitive Variants</h3> <p><img src="/assets/img/lec11_context_sensitivity_variants.96204b97.png" alt=""></p> <p>这就涉及到使用什么作为上下文标记了。</p> <h4 id="call-site-sensitivity"><a href="#call-site-sensitivity" class="header-anchor">#</a> Call-Site Sensitivity</h4> <p>Call-Site Sensitivity 是最朴素的想法，记录 Call-Site 就好了，Call-Site 串联起来不就是 Call Stack 么。</p> <p><img src="/assets/img/lec11_what_is_call_site_sensitivity.1072ce0c.png" alt=""></p> <p>但 Call-Site Sensitivity 存在着一定的问题，比如无法处理递归调用。</p> <p><img src="/assets/img/lec11_example_of_call_site_sensitivity.8be77ccd.png" alt=""></p> <p>容易想到可以通过限制 call chain 的长度来解决递归调用时 call chain 无法终止的问题，如下图所示：</p> <p><img src="/assets/img/lec11_what_is_k_call_site_sensitivity.880bb7c5.png" alt=""></p> <p>看一个例子：</p> <p><img src="/assets/img/lec11_example_of_1_call_site_start_state.58280313.png" alt=""></p> <p><img src="/assets/img/lec11_example_of_1_call_site_stop_state.653c7dbb.png" alt=""></p> <p>拿之前 C.I. 的结果进行对比，显然 1-call-site C.S. 的精度要好很多。</p> <p><img src="/assets/img/lec11_compare_ci_with_1_call_site.9a7f520c.png" alt=""></p> <h4 id="object-sensitivity"><a href="#object-sensitivity" class="header-anchor">#</a> Object Sensitivity</h4> <p><img src="/assets/img/lec11_what_is_object_sensitivity.9fe1122e.png" alt=""></p> <p>Call-Site 虽然实现简单也容易理解，但是在 OOPL 里，object 的链式调用使得 k-CFA 不那么好用，比如下面的例子里 1-call-site 精度要差于 1-object。</p> <p><img src="/assets/img/lec11_compare_1_call_site_and_object.1e381ec5.png" alt=""></p> <p><img src="/assets/img/lec11_compare_1_call_site_and_object_2.4d692d93.png" alt=""></p> <p>但也并不能说明 Ojbect Sensitivity 要比 Call-Site Sensitivity 要好，比如下面的例子中，1-call-site 就比 1-object 精度要好。</p> <p><img src="/assets/img/lec11_compare_object_and_1_call_site.4d2c050a.png" alt=""></p> <p>实际上，可以发现，在 OOPL 里，Object Sensitivity 中使用 object 作为 Context 可以穿透调用链，使得 k-object 的 'k' 比实际要大得多。</p> <h4 id="object-sensitivity-2"><a href="#object-sensitivity-2" class="header-anchor">#</a> Object Sensitivity</h4> <p><img src="/assets/img/lec11_what_is_type_sensitivity.9ddd87c1.png" alt=""></p> <h4 id="summary-2"><a href="#summary-2" class="header-anchor">#</a> Summary</h4> <p><img src="/assets/img/lec11_statistical_data_of_call_site_object_and_type_sensitivity.aec2bceb.png" alt=""></p> <h2 id="lec13-static-analysis-for-security"><a href="#lec13-static-analysis-for-security" class="header-anchor">#</a> Lec13 Static Analysis for Security</h2> <p>主要讲了污点分析，但感觉和前面大差不差啊，留着后面整理吧。</p> <h2 id="lec14-datalog-based-programming-language"><a href="#lec14-datalog-based-programming-language" class="header-anchor">#</a> Lec14 Datalog-Based Programming Language</h2> <p>Datalog 是声明式逻辑语言，当然和 SQL 一样似乎只是一个标准，其实现各有不同。</p> <p><img src="/assets/img/lec14_so_many_implementation_details_in_pointer_analysis.e666cfd5.png" alt=""></p> <p>学了这么多语言，感觉 Datalog 就语法上简单得很啊。就不过多介绍了，直接贴 Datalog 实现的 Pointer Analysis Alogirithm。</p> <p><img src="/assets/img/lec14_datalog_implementation_of_pointer_analysis.920b9e34.png" alt=""></p> <p>当然，Datalog 并非完美的，理由如下：</p> <ol><li>Datalog 不是图灵完备的，表达能力有限，如 Datalog 里的数据只能增加，无法删除。</li> <li>Datalog 实际执行是一个黑盒子，看起来简洁的语法背后是执行引擎，这使得将优化的范围缩小了，不利于优化。</li></ol> <h3 id="introduction-of-datalog"><a href="#introduction-of-datalog" class="header-anchor">#</a> Introduction of Datalog</h3> <p><img src="/assets/img/lec14_atom_in_datalog.ec22146e.png" alt=""></p> <p><img src="/assets/img/lec14_logic_in_datalog.895d3c05.png" alt=""></p> <p><img src="/assets/img/lec14_datalog_example.68ed0863.png" alt=""></p> <p><img src="/assets/img/lec14_datalog_program.62867f8c.png" alt=""></p> <p><img src="/assets/img/lec14_edb_and_idb_in_datalog.d6085b66.png" alt=""></p> <p><img src="/assets/img/lec14_rule_safety_in_datalog.a93ff61d.png" alt=""></p> <h3 id="c-i-pointer-analysis-via-datalog"><a href="#c-i-pointer-analysis-via-datalog" class="header-anchor">#</a> C.I. Pointer Analysis via Datalog</h3> <p><img src="/assets/img/lec14_pointer_analysis_via_datalog.65abacf5.png" alt=""></p> <p><img src="/assets/img/lec14_datalog_model_for_pointer_analysis.0b4060bb.png" alt=""></p> <p><img src="/assets/img/lec14_datalog_rules_for_pointer_analysis.0b6eb356.png" alt=""></p> <p><img src="/assets/img/lec14_datalog_rules_for_pointer_analysis_method_call.277583de.png" alt=""></p> <p><img src="/assets/img/lec14_whole_program_pointer_analysis.2c1339ce.png" alt=""></p> <h3 id="taint-analysis-via-datalog"><a href="#taint-analysis-via-datalog" class="header-anchor">#</a> Taint Analysis via Datalog</h3> <p><img src="/assets/img/lec14_datalog_model_for_taint_analysis.153e8835.png" alt=""></p> <p><img src="/assets/img/lec14_taint_analysis_via_datalog.56b7a79e.png" alt=""></p> <h2 id="lec15-cfl-reachability-and-ifds"><a href="#lec15-cfl-reachability-and-ifds" class="header-anchor">#</a> Lec15 CFL-Reachability and IFDS</h2> <h2 id="lec16-soundness-and-soundiness"><a href="#lec16-soundness-and-soundiness" class="header-anchor">#</a> Lec16 Soundness and Soundiness</h2></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-7c337468 data-v-757b4ec5><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#write-in-front" class="sidebar-link reco-side-write-in-front" data-v-7c337468>Write in Front</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec1-introduction" class="sidebar-link reco-side-lec1-introduction" data-v-7c337468>Lec1 Introduction</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec2-intermediate-representation" class="sidebar-link reco-side-lec2-intermediate-representation" data-v-7c337468>Lec2 Intermediate Representation</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#control-flow-graph" class="sidebar-link reco-side-control-flow-graph" data-v-7c337468>Control Flow Graph</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec3-4-data-flow-analysis-application" class="sidebar-link reco-side-lec3-4-data-flow-analysis-application" data-v-7c337468>Lec3~4 Data Flow Analysis - Application</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#reaching-definition-analysis" class="sidebar-link reco-side-reaching-definition-analysis" data-v-7c337468>Reaching Definition Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#live-variable-analysis" class="sidebar-link reco-side-live-variable-analysis" data-v-7c337468>Live Variable Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#available-expression-analysis" class="sidebar-link reco-side-available-expression-analysis" data-v-7c337468>Available Expression Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#summary" class="sidebar-link reco-side-summary" data-v-7c337468>Summary</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec5-6-data-flow-analysis-foundations" class="sidebar-link reco-side-lec5-6-data-flow-analysis-foundations" data-v-7c337468>Lec5~6 Data Flow Analysis Foundations</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#fix-pointer-view-of-dfa" class="sidebar-link reco-side-fix-pointer-view-of-dfa" data-v-7c337468>Fix Pointer View of DFA</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#partial-order" class="sidebar-link reco-side-partial-order" data-v-7c337468>Partial Order</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lattice" class="sidebar-link reco-side-lattice" data-v-7c337468>Lattice</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#fix-point-theorem" class="sidebar-link reco-side-fix-point-theorem" data-v-7c337468>Fix Point Theorem</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lattice-view-of-may-and-must-analysis" class="sidebar-link reco-side-lattice-view-of-may-and-must-analysis" data-v-7c337468>Lattice View of May and Must Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#meet-over-all-path-mop" class="sidebar-link reco-side-meet-over-all-path-mop" data-v-7c337468>Meet Over All Path(MOP)</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#constant-propagation" class="sidebar-link reco-side-constant-propagation" data-v-7c337468>Constant Propagation</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#worklist-alogirithm" class="sidebar-link reco-side-worklist-alogirithm" data-v-7c337468>WorkList Alogirithm</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec7-interprocedural-analysis" class="sidebar-link reco-side-lec7-interprocedural-analysis" data-v-7c337468>Lec7 Interprocedural Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#function-call-in-java" class="sidebar-link reco-side-function-call-in-java" data-v-7c337468>Function Call In Java</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#method-dispatch-for-virtual-call" class="sidebar-link reco-side-method-dispatch-for-virtual-call" data-v-7c337468>Method Dispatch for Virtual Call</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#class-hierarchy-analysis" class="sidebar-link reco-side-class-hierarchy-analysis" data-v-7c337468>Class Hierarchy Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#interprocedural-control-flow-graph" class="sidebar-link reco-side-interprocedural-control-flow-graph" data-v-7c337468>Interprocedural Control Flow Graph</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#interprocedural-constant-propagation" class="sidebar-link reco-side-interprocedural-constant-propagation" data-v-7c337468>Interprocedural Constant Propagation</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec8-pointer-analysis" class="sidebar-link reco-side-lec8-pointer-analysis" data-v-7c337468>Lec8 Pointer Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#key-factor-in-pointer-analysis" class="sidebar-link reco-side-key-factor-in-pointer-analysis" data-v-7c337468>Key Factor in Pointer Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#heap-abstraction" class="sidebar-link reco-side-heap-abstraction" data-v-7c337468>Heap Abstraction</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#context-sensitivity" class="sidebar-link reco-side-context-sensitivity" data-v-7c337468>Context Sensitivity</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#flow-sensitivity" class="sidebar-link reco-side-flow-sensitivity" data-v-7c337468>Flow Sensitivity</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#analysis-scope" class="sidebar-link reco-side-analysis-scope" data-v-7c337468>Analysis Scope</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#concerned-statement" class="sidebar-link reco-side-concerned-statement" data-v-7c337468>Concerned Statement</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec9-10-pointer-analysis-foundations" class="sidebar-link reco-side-lec9-10-pointer-analysis-foundations" data-v-7c337468>Lec9~10 Pointer Analysis Foundations</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#implement-pointer-analysis" class="sidebar-link reco-side-implement-pointer-analysis" data-v-7c337468>Implement Pointer Analysis</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#pointer-flow-graph" class="sidebar-link reco-side-pointer-flow-graph" data-v-7c337468>Pointer Flow Graph</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#pointer-analysis-algorithm-without-method-call" class="sidebar-link reco-side-pointer-analysis-algorithm-without-method-call" data-v-7c337468>Pointer Analysis Algorithm Without Method Call</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#pointer-analysis-algorithm-with-method-call" class="sidebar-link reco-side-pointer-analysis-algorithm-with-method-call" data-v-7c337468>Pointer Analysis Algorithm With Method Call</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec11-12-pointer-analysis-context-sensitivity" class="sidebar-link reco-side-lec11-12-pointer-analysis-context-sensitivity" data-v-7c337468>Lec11~12 Pointer Analysis Context Sensitivity</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#context-sensitive-heap" class="sidebar-link reco-side-context-sensitive-heap" data-v-7c337468>Context Sensitive Heap</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#context-sensitive-pointer-analysis-rule" class="sidebar-link reco-side-context-sensitive-pointer-analysis-rule" data-v-7c337468>Context Sensitive Pointer Analysis Rule</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#context-sensitive-pointer-analysis-algorithm" class="sidebar-link reco-side-context-sensitive-pointer-analysis-algorithm" data-v-7c337468>Context Sensitive Pointer Analysis Algorithm</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#context-sensitive-variants" class="sidebar-link reco-side-context-sensitive-variants" data-v-7c337468>Context Sensitive Variants</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec13-static-analysis-for-security" class="sidebar-link reco-side-lec13-static-analysis-for-security" data-v-7c337468>Lec13 Static Analysis for Security</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec14-datalog-based-programming-language" class="sidebar-link reco-side-lec14-datalog-based-programming-language" data-v-7c337468>Lec14 Datalog-Based Programming Language</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#introduction-of-datalog" class="sidebar-link reco-side-introduction-of-datalog" data-v-7c337468>Introduction of Datalog</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#c-i-pointer-analysis-via-datalog" class="sidebar-link reco-side-c-i-pointer-analysis-via-datalog" data-v-7c337468>C.I. Pointer Analysis via Datalog</a></li><li class="level-3" data-v-7c337468><a href="/Static%20Program%20Analysis.html#taint-analysis-via-datalog" class="sidebar-link reco-side-taint-analysis-via-datalog" data-v-7c337468>Taint Analysis via Datalog</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec15-cfl-reachability-and-ifds" class="sidebar-link reco-side-lec15-cfl-reachability-and-ifds" data-v-7c337468>Lec15 CFL-Reachability and IFDS</a></li><li class="level-2" data-v-7c337468><a href="/Static%20Program%20Analysis.html#lec16-soundness-and-soundiness" class="sidebar-link reco-side-lec16-soundness-and-soundiness" data-v-7c337468>Lec16 Soundness and Soundiness</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-2a01419c data-v-2a01419c><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-2a01419c><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-2a01419c></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-2a01419c></path></svg></div></div></div>
    <script src="/assets/js/app.28690c83.js" defer></script><script src="/assets/js/7.1117b569.js" defer></script><script src="/assets/js/2.2baf8a55.js" defer></script><script src="/assets/js/1.e277d7c2.js" defer></script><script src="/assets/js/14.f66e0ed2.js" defer></script>
  </body>
</html>
